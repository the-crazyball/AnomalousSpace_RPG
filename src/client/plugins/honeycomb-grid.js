(function(u,h){typeof exports=="object"&&typeof module<"u"?h(exports):typeof define=="function"&&define.amd?define(["exports"],h):(u=typeof globalThis<"u"?globalThis:u||self,h(u.Honeycomb={}))})(this,function(u){"use strict";const h=e=>Number.isFinite(e)&&!Number.isNaN(e),N=e=>typeof e=="object"&&e!==null,rt=e=>N(e)&&h(e.q)&&h(e.r),st=e=>typeof e=="function",O=e=>N(e)&&h(e.col)&&h(e.row),z=e=>N(e)&&h(e.x)&&h(e.y),R=e=>Array.isArray(e)&&h(e[0])&&h(e[1]),E=(e,t)=>t+e*(t&1)>>1;function ot(e,t){return(e%t+t)%t}const it=(e,t)=>ot(e+t,8),P=([e,t,n=-e-t])=>({q:e,r:t,s:n});function x({q:e,r:t,s:n}){const r=h(e),s=h(t),o=h(n);if(r&&s&&o)return{q:e,r:t,s:n};if(r&&s)return{q:e,r:t,s:-e-t};if(r&&o)return{q:e,r:-e-n,s:n};if(s&&o)return{q:-t-n,r:t,s:n};throw new TypeError(`Can't determine three cube coordinates from less than two coordinates. Received: { q: ${e}, r: ${t}, s: ${n} }.`)}var d=(e=>(e.FLAT="FLAT",e.POINTY="POINTY",e))(d||{});function U(e,t){if(N(e)&&e.xRadius>0&&e.yRadius>0)return e;if(N(e)&&e.width>0&&e.height>0){const{width:n,height:r}=e;return t===d.POINTY?{xRadius:n/Math.sqrt(3),yRadius:r/2}:{xRadius:n/2,yRadius:r/Math.sqrt(3)}}if(e>0)return{xRadius:e,yRadius:e};throw new TypeError(`Invalid dimensions: ${JSON.stringify(e)}. Dimensions must be expressed as an Ellipse ({ xRadius: number, yRadius: number }), a Rectangle ({ width: number, height: number }) or a number.`)}function _(e,t){if(z(e))return e;if(!t)throw new TypeError(`Supply a bounding box ({ width: number, height: number }). Received: ${JSON.stringify(t)}`);if(e==="topLeft")return{x:t.width*-.5,y:t.height*-.5};throw new TypeError(`Invalid origin: ${JSON.stringify(e)}. Origin must be expressed as a Point ({ x: number, y: number }) or the string 'topLeft'.`)}class W{static get settings(){const{dimensions:t,orientation:n,origin:r,offset:s}=this.prototype;return{dimensions:t,orientation:n,origin:r,offset:s}}get center(){const{width:t,height:n,x:r,y:s}=this;return{x:t/2-r,y:n/2-s}}get col(){return p(this).col}get corners(){const{orientation:t,width:n,height:r,x:s,y:o}=this;return t===d.POINTY?ct(n,r,s,o):ut(n,r,s,o)}get dimensions(){return b.dimensions}get height(){const{orientation:t,dimensions:{yRadius:n}}=this;return t===d.POINTY?n*2:n*Math.sqrt(3)}get isFlat(){return this.orientation===d.FLAT}get isPointy(){return this.orientation===d.POINTY}get orientation(){return b.orientation}get origin(){return b.origin}get offset(){return b.offset}get row(){return p(this).row}get width(){const{orientation:t,dimensions:{xRadius:n}}=this;return t===d.POINTY?n*Math.sqrt(3):n*2}get x(){return $(this).x}get y(){return $(this).y}get s(){return-this.q-this.r}q;r;constructor(t=[0,0]){const{q:n,r}=w(this,t);this.q=n,this.r=r}clone(t=this){return new this.constructor(t)}equals(t){return k(this,O(t)?B(this,t):t)}toString(){return`${this.constructor.name}(${this.q},${this.r})`}translate(t){return X(this,t)}}const b={dimensions:{xRadius:1,yRadius:1},orientation:d.POINTY,origin:{x:0,y:0},offset:-1},ct=(e,t,n,r)=>[{x:n+e*.5,y:r-t*.25},{x:n+e*.5,y:r+t*.25},{x:n,y:r+t*.5},{x:n-e*.5,y:r+t*.25},{x:n-e*.5,y:r-t*.25},{x:n,y:r-t*.5}],ut=(e,t,n,r)=>[{x:n+e*.25,y:r-t*.5},{x:n+e*.5,y:r},{x:n+e*.25,y:r+t*.5},{x:n-e*.25,y:r+t*.5},{x:n-e*.5,y:r},{x:n-e*.25,y:r-t*.5}];function Z(e){const{dimensions:t,orientation:n,origin:r,offset:s}={...b,...e};return class extends W{get dimensions(){return U(t,n)}get orientation(){return n}get origin(){return _(r,this)}get offset(){return s}}}function k(e,t){if(O(e)&&O(t))return e.col===t.col&&e.row===t.row;if(Object.hasOwn(e,"col")||Object.hasOwn(t,"col"))throw new Error(`Can't compare coordinates where one are offset coordinates. Either pass two offset coordinates or two axial/cube coordinates. Received: ${JSON.stringify(e)} and ${JSON.stringify(t)}`);const n=R(e)?P(e):e,r=R(t)?P(t):t;return n.q===r.q&&n.r===r.r}const ft=(e,t,n)=>({col:e+E(n,t),row:t}),ht=(e,t,n)=>({col:e,row:t+E(n,e)}),p=({q:e,r:t,offset:n,isPointy:r})=>r?ft(e,t,n):ht(e,t,n),$=({orientation:e,dimensions:{xRadius:t,yRadius:n},origin:{x:r,y:s},q:o,r:i})=>e===d.POINTY?{x:t*Math.sqrt(3)*(o+i/2)-r,y:n*3/2*i-s}:{x:t*3/2*o-r,y:n*Math.sqrt(3)*(i+o/2)-s},Y=(e,t,n)=>{const r=e-E(n,t),s=t,o=-r-s;return{q:r,r:s,s:o}},J=(e,t,n)=>{const r=e,s=t-E(n,e),o=-r-s;return{q:r,r:s,s:o}},B=({offset:e,orientation:t},{col:n,row:r})=>t===d.POINTY?Y(n,r,e):J(n,r,e),F=e=>{const{q:t,r:n,s:r}=x(e);let s=Math.round(t),o=Math.round(n),i=Math.round(r);const c=Math.abs(t-s),f=Math.abs(n-o),l=Math.abs(r-i);return c>f&&c>l?s=-o-i:f>l?o=-s-i:i=-s-o,{q:s,r:o,s:i}},V=({dimensions:{xRadius:e,yRadius:t},origin:n,orientation:r},{x:s,y:o})=>(s+=n.x,o+=n.y,r===d.POINTY?F({q:Math.sqrt(3)*s/(3*e)-o/(3*t),r:2/3*(o/t)}):F({q:2/3*(s/e),r:Math.sqrt(3)*o/(3*t)-s/(3*e)}));function w(e,t){return R(t)?P(t):O(t)?B(e,t):x(t)}function X(e,t){const{q:n,r,s}=x(e),{q:o,r:i,s:c}=x(t),f={q:n+o,r:r+i,s:s+c};return e instanceof W?e.clone(f):f}function I(e,t,n){const{q:r,r:s,s:o}=w(e,t),{q:i,r:c,s:f}=w(e,n);return Math.max(Math.abs(r-i),Math.abs(s-c),Math.abs(o-f))}var L=(e=>(e.CLOCKWISE="CLOCKWISE",e.COUNTERCLOCKWISE="COUNTERCLOCKWISE",e))(L||{}),a=(e=>(e[e.N=0]="N",e[e.NE=1]="NE",e[e.E=2]="E",e[e.SE=3]="SE",e[e.S=4]="S",e[e.SW=5]="SW",e[e.W=6]="W",e[e.NW=7]="NW",e))(a||{});const at=[null,{q:1,r:-1},{q:1,r:0},{q:0,r:1},null,{q:-1,r:1},{q:-1,r:0},{q:0,r:-1}],lt=[{q:0,r:-1},{q:1,r:-1},null,{q:1,r:0},{q:0,r:1},{q:-1,r:1},null,{q:-1,r:0}],gt=({offset:e,q:t,r:n,col:r,row:s},o)=>{if(o===a.S||o===a.N){const c=o===a.S?s+1:s-1;return Y(r,c,e)}const i=at[o];return{q:t+i.q,r:n+i.r}},dt=({offset:e,q:t,r:n,col:r,row:s},o)=>{if(o===a.E||o===a.W){const c=o===a.E?r+1:r-1;return J(c,s,e)}const i=lt[o];return{q:t+i.q,r:n+i.r}},A=(e,t)=>e.clone(e.isPointy?gt(e,t):dt(e,t));function C(e){return Array.isArray(e)?function(n,r){const s=[];let o=r;for(const i of e)for(const c of i(n,o))s.push(o=c);return s}:e}const mt=(...e)=>t=>e.map(t);function v(e){return qt(e)?yt(e):Tt(e)}function qt(e){return e.direction in a}function yt({start:e,direction:t,length:n}){return function(s,o){const i=[];let f=s(e??o);!e&&o&&(f=A(f,t));for(let l=0;l<n;l++)i.push(f),f=A(f,t);return i}}function Tt({start:e,stop:t}){return function(r,s){const o=[],i=r(e??s),c=D(i),f=D(w(i,t)),l=Ot(c,f),g=I(i,i,t),S=1/Math.max(g,1);let T=!e&&s?1:0;for(T;T<=g;T++){const H=F(l(S*T));o.push(r(H))}return o}}function D({q:e,r:t,s:n}){return{q:e+1e-6,r:t+1e-6,s:n+-2e-6}}function Ot(e,t){return n=>{const r=e.q*(1-n)+t.q*n,s=e.r*(1-n)+t.r*n;return{q:r,r:s}}}const xt=e=>(t,n)=>[A(t(n),e)];function j(e,t,{includeSource:n=!0}={}){return function(s,o){const i=[];for(const c of C(e)(s,o)){n&&i.push(c);for(const f of C(t)(s,c))i.push(f)}return i}}function bt(e,t){return function(r,s){const{width:o,height:i,start:c,direction:f=a.E}=t?wt(e,t,r()):e,l=c??s??[0,0],g=j(v({start:l,direction:it(f,2),length:i}),v({direction:f,length:o-1}))(r,l);return!c&&s?g.slice(1):g}}function wt(e,t,{isPointy:n,offset:r}){const{col:s,row:o}=G(e,n,r),{col:i,row:c}=G(t,n,r),f=s<i?"A":"B",l=o<c?"A":"B",g=f+l,{swapWidthHeight:S,direction:T}=Ct[g],H=Math.abs(s-i)+1,m=Math.abs(o-c)+1;return{width:S?m:H,height:S?H:m,start:e,direction:T}}function G(e,t,n){if(O(e))return e;const{q:r,r:s}=R(e)?P(e):x(e);return p({q:r,r:s,isPointy:t,offset:n})}const Ct={AA:{swapWidthHeight:!1,direction:a.E},AB:{swapWidthHeight:!0,direction:a.N},BA:{swapWidthHeight:!0,direction:a.S},BB:{swapWidthHeight:!1,direction:a.W}};function St(e,t){return C(Array.from({length:e},()=>C(t)))}function tt(e){const{center:t,rotation:n=L.CLOCKWISE}=e;return function(s,o){const i=n.toUpperCase(),c=[];let{radius:f}=e;const l=h(f);let g;l?g=s(t).translate({q:f,s:-f}):(g=s(e.start??o),f=I(g,t,g));const{q:S,r:T,s:H}=w(g,t);let m=s({q:S,r:T-f,s:H+f});if(i===L.CLOCKWISE)for(let y=0;y<6;y++)for(let M=0;M<f;M++){const{q:K,r:Q}=et[y];m=s({q:m.q+K,r:m.r+Q}),c.push(m)}else for(let y=5;y>=0;y--)for(let M=0;M<f;M++){const{q:K,r:Q}=et[y];m=s({q:m.q-K,r:m.r-Q}),c.push(m)}const Nt=l?!1:!e.start&&o,nt=c.findIndex(y=>y.equals(g));return c.slice(nt+(Nt?1:0)).concat(c.slice(0,nt))}}const et=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}];function Ht({radius:e,start:t,rotation:n}){return function(s,o){const i=t??o??[0,0],c=!t&&o?e:e+1;return j(v({start:t,direction:a.N,length:c}),tt({center:i,rotation:n}))(s,o)}}class q{static fromIterable(t){const n=t[Symbol.iterator]().next().value;if(!n)throw new TypeError(`Can't create grid from empty iterable: ${JSON.stringify(t)}`);return new q(n.constructor,t)}static fromJSON({hexSettings:t,coordinates:n},r){if(r){const o=n.map(r),i=o.length>0?o[0].constructor:r({q:0,r:0},0,[{q:0,r:0}]).constructor;return new q(i,o)}const s=Z(t);return new q(s,n.map(o=>new s(o)))}get size(){return this.#e.size}get pixelWidth(){if(this.size===0)return 0;const{isPointy:t,width:n}=this.hexPrototype,r=this.toArray(),{0:s,length:o,[o-1]:i}=t?r.sort((c,f)=>f.s-c.s||c.q-f.q):r.sort((c,f)=>c.q-f.q);return i.x-s.x+n}get pixelHeight(){if(this.size===0)return 0;const{isPointy:t,height:n}=this.hexPrototype,r=this.toArray(),{0:s,length:o,[o-1]:i}=t?r.sort((c,f)=>c.r-f.r):r.sort((c,f)=>f.s-c.s||c.r-f.r);return i.y-s.y+n}[Symbol.iterator](){return this.#e.values()}get hexPrototype(){return this.#t.prototype}#t;#e=new Map;constructor(t,n=[]){if(t instanceof q){this.#t=t.#t,this.setHexes(t);return}this.#t=t,this.setHexes(this.#r(n))}createHex(t){return new this.#t(t)}getHex(t){const n=this.createHex(t);return this.#e.get(n.toString())}hasHex(t){return this.#e.has(t.toString())}setHexes(t){for(const n of t){const r=n instanceof W?n:new this.#t(n);this.#n(r)}return this}filter(t){const n=new q(this.#t);for(const r of this)t(r)&&n.#n(r);return n}map(t){const n=new q(this.#t);for(const r of this)n.#n(t(r));return n}traverse(t,{bail:n=!1}={}){const r=new q(this.#t);for(const s of this.#r(t)){const o=this.getHex(s);if(o)r.#n(o);else if(n)return r}return r}forEach(t){for(const n of this)t(n);return this}reduce(t,n){if(n===void 0){let s,o,i;for(const c of this)o=i,i=c,o&&(s=t(o,i));return s}let r=n;for(const s of this)r=t(r,s);return r}toArray(){return Array.from(this)}toJSON(){const{dimensions:t,orientation:n,origin:r,offset:s}=this.hexPrototype;return{hexSettings:{dimensions:t,orientation:n,origin:r,offset:s},coordinates:this.toArray()}}toString(){return`${this.constructor.name}(${this.size})`}pointToHex(t,{allowOutside:n=!0}={}){const r=V(this.hexPrototype,t),s=this.getHex(r);return n?s??this.createHex(r):s}distance(t,n,{allowOutside:r=!0}={}){if(r)return I(this.hexPrototype,t,n);const s=this.getHex(t),o=this.getHex(n);if(!(!s||!o))return I(this.hexPrototype,s,o)}neighborOf(t,n,{allowOutside:r=!0}={}){const s=A(this.createHex(t),n),o=this.getHex(s);return r?o??s:o}#n(t){this.#e.set(t.toString(),t)}#r(t){return this.#s(t)?this.#o(t):Array.isArray(t)&&this.#s(t[0])?this.#o(C(t)):t}#s(t){return st(t)}#o(t){return t(this.createHex.bind(this))}}u.Direction=a,u.Grid=q,u.Hex=W,u.Orientation=d,u.Rotation=L,u.completeCube=x,u.concat=C,u.createHexDimensions=U,u.createHexOrigin=_,u.defaultHexSettings=b,u.defineHex=Z,u.distance=I,u.equals=k,u.fromCoordinates=mt,u.hexToOffset=p,u.hexToPoint=$,u.isAxial=rt,u.isOffset=O,u.isPoint=z,u.isTuple=R,u.line=v,u.move=xt,u.neighborOf=A,u.offsetFromZero=E,u.offsetToCube=B,u.offsetToCubeFlat=J,u.offsetToCubePointy=Y,u.pointToCube=V,u.rectangle=bt,u.repeat=St,u.repeatWith=j,u.ring=tt,u.round=F,u.spiral=Ht,u.toCube=w,u.translate=X,u.tupleToCube=P,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});